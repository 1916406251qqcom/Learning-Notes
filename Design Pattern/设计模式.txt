设计模式：

创建型模式------------------------------------------------------------------------------------------------
工厂模式：	工厂生产东西
	当一个A类是经常变换的，并且它其中需要调用的耦合的返回的B类也是经常需要变换的
	这时候可以利用多态
	--利用一个抽象的类生成A类，在创建一个抽象的接口生成B类
	--在A的父类中既可以定义一个返回B的父接口
	--那么在A这个实现类中，就可以返回一个B的接口，但是在其中定义的是一个A类的对象，返回它的接口
	--在调用的时候，就可以直接new A的类，多态时A，再调用方法时，此时返回的就是B的接口，
	--但是因为在A类中虽然返回的是B的接口，但是因为其中的实现时B类，所以便是最终产生的是B
	--ps：如果需要另一个类的时候继续利用两个多态进行创建即可，注意A必须是一个继承的关系，只有这样
              才可以实现将子类的数据设置到父类中，如果是接口的话，害得需要new，然后调用方法才可以得到值

	--A接口返回B接口，A的实现类中也可以返回B，需要在返回方法中new 一个B的实现类，工厂生产（一句话可以概括）

	--jdk中的应用：List，比如arraylist和linkedlist，其中的iterator相当于一个抽象产品，
	   List相当于一个抽象工厂


抽象工厂模式：	家族的建造
	就是一个工厂模式，只是工厂模式是通过继承的方式实现数据的设置，而抽象的是通过组合的方式实现数据设置
	并且抽象的是创建一个家族，而普通的只是创建一个具体的类

	--jdk中的应用：java.sql.drivermanager，getConnection()的方法


建造者模式：	造人  男/女建造器
	当需要创建的对象很复杂时，可能以后还会改变，那么可以采用建造者模式
	
	--1.需要有一个接口A（人）提供一个具体建造的方法，另外提供一个得到最终对象模板的方法
	     重点是需要有一个提供最终对象接口的方法，这样才可以在它的子类建造器中new 出具体的复杂对象
	    并且返回一个接口
	--2.还需要一个接口B（机器）（复杂对象的抽象），因为生成的复杂对象可能有几种，那么这时候就需要一个抽象的类
	--3.这时候需要创建一个建造C（具体的机器）（C是一个建造复杂对象的类，复杂对象是c（男人或者女人等。。）），
	    C实现B，在其中new 出c。注意c必须实现A，这样才可以在建造起中new出c并且返回值为A
            为c设置它需要的一些东西，A是他的父亲，C其实就是一个建造者，B只是为它服务
	    后续可以设定更多的Dd，Ee等，每一个复杂的对象都需要有一个建造者
	--3.还需要有一个类M，这个类叫做中介。首先从提供的参数（建造器），获取最终复杂对象的方法
	    这个中介返回值为A（人），他会根据传入的建造器（B）来得到相应的对象
	    所以这个M是不变的
	--5.在这个过程中其实改变的只是c（它实现的A，即复杂对象的抽象接口）和C（它实现的B，即机器的最终接口）
	    每一个建造器的机器对应它自己需要建造的复杂对象，只是返回值是对象的抽象接口

	--jdk中的实现：stringbuffer在其中有一个value，这里面存储着数据，而insert和append等都是对这个进行操作
	  之后tostring()方法将value值打印出来，这即是一个建造成品对象出炉的过程。而其中的append等方法即就是
          建造的加工


原型设计模式：  克隆
	当需要创建一些比较复杂的对象时，如果自行创建，那么会特别麻烦，所以可以采用克隆的方式
	
	--1.原型设计模式首先需要一个类最好是接口A，里面有一个方法getNameObject(),获取对象
	    并且还有一个被克隆对象的引用
	--2.那么现在还需要一个需要被克隆的对象B。
	    这个B必须实现Cloneble，这个接口是一个标记接口，说明可以被克隆，
	    而且在需要被克隆的对象中还需要复写一个clone，这个方法是object的，
	--3.在getNameObject的方法中需要加判断，如果A中的引用为null，那么就需要新创建一个对象
	    如果A中的引用不为空那么直接将B对象克隆B.clone()，然后将这个值返回

	以上是浅克隆：克隆只是将数据结构类型克隆了，但是本质依然没有变
	如果要改为深客隆：那么必须要在重载clone的时候，将数组和对象引用也进行拷贝，这样才是深克隆
	  数组等对象引用的克隆，即就是
	      		Test tClone = super.clone()//这个调用的object的方法
			this.list = this.list.clone();
	  返回一个Tets，这个是深度克隆的对象

	jdk中的引用：Object其中就有一个clone方法

单例设计模式：	唯一对象
	要得到唯一的对象
	
	jdk中的引用：runtime是唯一的
	框架中的引用：sqlsessionfactory以及sessionfactory都是单例的，session是存储在threadlocal中的

结构型的模式-------------------------------------------------------------------------------------


适配器模式：	功能进行适配
	当功能需要扩展时，可以使用这种模式
	当需要进行某种特定的调整时，使用

	--适配器模式相当于一个接口对另一个接口的适配

	--装饰者模式设计上十分类似，只是这个模式主要是完全的增加一些新的功能
	
	jdk中的应用：inputstermreader等，linkedhashmap


桥接模式：	相交
	不希望抽象类和实现类有一个固定的绑定关系

	--1.给相同类型的a1,a2抽象一个接口A，给相同类型的两个b1，b2抽象一个接口B
	--2.现在给A的构造方法中传递接口B，这样就可以new出出身于A的b了。或者直接在A中有一个B的引用
	--3.那么现在需要a1和b1结合，如果是构造传递的话，就是
				B B1 = new b1();
				A A1 = new a1(B);
				这样A1即就是a1和b1了
	   如果是引用的话，那么：
				A A1 = new a1();
				A.B AB= new b1(); 
				这样AB即就是a1和b1了

	jdk中的应用new linkedhashmap(linkedhashset,list)返回一个不可修改的linkedmap

组合模式：	公平对待公司员工（管理层和普通员工）
	类似于公司架构，管理级别和普通人员，他们很多地方一样，只是个别不一样，如果分别对两种成员进行实现，那么
	会造成很大的冗余。如果是抽象编程 的话，即就是将共有的提出来，管理和普通各自重新实现一些东西。
	但是这样做还是不满意，所以采用实现所有的东西，将所有的东西都抽象出来，管理层抽象添加和删除，普通员工的普通工作
	全部抽象起来，管理层只用实现自己的东西，不实现普通工作。普通员工只实现普通工作，对于增加删除不实现
	这样就将所有的人员统一对待了

	--1.抽象一个类，这个类是抽象类，。因为抽象类的话可以实现一些别的东西，比如可以又构造函数，这样的话相当于统筹了所有的功能
	   抽象不一定非得是接口，这里需要的其实是一个类，抽象类，拥有构造函数

	--2.使用管理类去继承它，实现管理类需要实现的抽象方法，不实现普通的方法
	--3.使用普通员工类继承它，复写普通方法，不用复写管理方法

	jdk中的应用：map的putall(map)，这使得所有的map都有putall这个方法，直接可以添加，不同的map实现类


装饰者模式：
	当需要扩增一个类的时候，但是又不想改变原有类的一些定义，那么就在原有类上进行扩充，采用继承的方式
	现在有一个类A，但是因为太旧，所以先更新一下，但是有类中东西太多，没法重写，所以使用这个模式
	如果使用这个方法--创建一个B类，继承A，调用A的方法，并且在A的基础上进行扩增，那么会造成继承的类太多
	一般就是当一个变化太快或者太多不可控的时候可以使用

	--1.创建一个接口，这个接口是原有类的直接实现接口，其他装饰着又继承原有类
	--2.在原始类中定义了一个接口的引用，在构造方法中传入，然后用接口的引用来实现其中的方法
	--2.需要更改时，创建一个新的类，继承这个类，然后只需要创建之后传入一个原来类的对象即可。

	相比较以前的东西，主要添加了一个接口，每次传入这个接口即就是将以前的类进行一次装饰，还有点像责任链模式
	

	jdk中的应用：inputstream或者Reader等

外观模式：	不会注册公司，找一个中介来
	如果系统比较复杂时，我们不可能一一调用，所以这时就需要一个类似于中介者去转发这个流程，只提供一个对外的简答的方法供外部调用

	--1.直接创建一个新的类，将以前的类传递进来，这个类提供一个方法用来封装对以前的类的复杂的操作流程
	中介类进行转移

	jdk中的应用：logger类，里面辅助类比较多，需要很多流程，所以会提供一个简单的操作


享元模式：	五子棋，每一个棋子都是一个对象
	当某个对象的实例太多时，他们之间的差距不太大时
	编程中会遇到一些特别是棋盘类游戏的程序，每一个棋子都会包含棋子的一些信息，而这个棋子的数量是十分多的，所以不能创建那么多的对象

	--1.享元模式其实就是共享对象
	--2.分为内蕴和外蕴
	   内蕴：定义一个工厂建造类（工厂模式），也是一个单例的模式，在里面维护了一个hashmap如果是线程安全那么还需要currenthashmap
		 不同的对象首先进行判断是否存在，如果不存在那么创建并保存，如果存在那么直接根据key获取即可
	   外蕴：虽然对象是共享的但是必然有一些不同的地方，那么这时候就需要内蕴
		 既然那些独立的数据不能够放到缓存中，那么外蕴模式就是将一些特别的数据在客户端存储
		 即就是当共享对象得到之后，此时的对象还是一样的，出来之后再设置一些特别的不同的数据

	jdk中的应用：Integer类中的valueOf(）方法，将-127到127之间的数据如果再次赋值的话，那么会先判断是否存在缓存，存在那么从缓存中取出

代理模式：略



行为型模式---------------------------------------------------------------------------------------------------------------------------


责任链模式：
	当一些对象不清楚到底是谁来处理，或者一些对象需要经过多次的处理过滤，那么采用

	--1.创建一个接口A，这个目的就是让所有的需要进行处理的对象都实现。
	--2.这个模式的核心便是在每一A的实现类中都有一个setA(A。传入的是A的实现类)
	    在每一次的实现类操作完自己的功能后，判断是否有下一个A，因为setA是在初始化的时候设定的，所以判断一下
	    如果有，那么将每一个A中的A的引用来调用他自己的处理方法，然后他自己类中也有判断，继续执行
	
	这个模式有点类似于算法中的递归，一层一层的执行，只是这里递归的条件是我们在外面进行设置的，初始化时便设置a的b，b设置c，c设置d
	直到执行完abcd才一层一层返回，最终返回结果。


	web中的过滤器便是这种模式


命令模式：	邮局送信
	当一方不想与另一方进行具体的交互，解耦那么这时候即可采用
	
	--1.定义一个中间者，这个类需要有一个添加发送者的功能
	--2.定义一个接收者，接收者必须在其中传入中间这，这样才能将数据接收到

	jdk中的应用：action，事件，事件的发送者其实并不需呀知道谁是接收者，他只需要进行发送即可，接收者在类中定义中间着，这样即可接受消息


解释器模式：
	这个模式一般不常用，用于对一些特殊的东西进行解释

	jdk中的应用：时间 的format


迭代器模式：略



中介者模式：	一对多的说话

	当项目中一个模块和多个模块都有依赖关系，那么这时候系统就比较复杂
	
	--1.定义一个中介者，其中定义一个方法用于接收发送者以及发送者的消息
	--2.定义一个接口，这个接口目的是所有的接收者都实现
	--3.中介类中添加所有的被耦合模块，在中介中进行操作，这样便可以实现一个模块只对应一个中介者了

	jdk中应用：method的invoek方法，本来会依赖很多类，但现在只需要一对一即可


备忘录模式：	游戏中过关的备忘
	有点类似于版本控制工具的还原版本功能
	白箱模式：这种模式不安全
		--1.创建一个需要备忘的对象A
		--2.创建一个专门备忘的接口B，所有的备忘录都实现此接口
		--3.创建一个备忘录的管理类C，用来生成备忘录和重新获得备忘录对象
		每次使用的时候，A创建一个B的实例，即就是a-它是A的备忘对象，将a交给C，需要的时候C又还给A

	黑箱模式：
		核心是当创建A的实例时，实现B是在A的私有类中，即就是a是A的一个内部类
		那么现在便是a只属于A，以前是a谁都可以访问
	


观察者模式：	高温预警系统，向多个注册了的用户发送信息
	当一个系统中一个对象发生改变，相应的需要改变其他的观察者对象，而这时需要改变的对象数目我们又不知道，此时便可以采用这种模式
	这时候需要定义一个被观察者的接口，具备添加观察者的方法。这样首先注册观察者到被观察者中，当发生改变 时，直接向其中定义的所有观察者发送消息

	与中介者模式的区别：中介者模式中也具备发送消息的功能，那么这一方面属于观察者模式，但中介者模式注重的是各个模块系统的动作
			    而观察者模式注重的是信息的同步功能，主要体现在同步上	


	jdk中的应用：jdk中便有一个observable



状态模式：	个别的改变直接改变整体的类
	当修改背景等改变时，相应的背景也需要改变
	如果这个逻辑直接写的话，那么十分复杂，因为背景中包含的东西太多，必须全部修改
	那么现在就是直接修改相应的字段传递字段给一个专门用于切换的类。将每一种模式都封装一个类

	--1.创建一个公共的接口专门用于根据传入的字段改变相应的类
	--2.不同的类，这即就是不同的状态。根据相应个的字段进行改变每一个类的内容

	和策略模式其实十分类似

	这个模式中的结构即就是采用的组合模式

	jdk的应用：

策略模式：略


访问者模式：	公司架构
	当一个类中的结构很少变化，但是需要对结构中的对象进行多种操作，即就是结构不变但是结构中的内容变化，那么采用访问者模式

	将结构对象和操作功能解耦

	jdk中应用：


模板方法：
	即就是一个普通的接口，只不过这个接口中有一个方法将这些所有的方法整合起来，使用的时候只需要new每一个具体对象，实现其他的方法，直接调用模板方法

	方法复用性比较强





总结：	创建一个复杂对象-->可变的-->建造者模式
			   可能会重复-->原型模式
			   目的是简单使用-->外观模式
	创建一个对象-->可变的并且其中返回的对象也可变-->工厂模式
		       一个系列-->抽象工厂模式
		       需要适配别的地方-->适配器模式
		       需要增添一些新的功能-->装饰者模式
		       唯一化-->单例模式
		       和它类似的对象现在想和它看着公平-->组合模式


